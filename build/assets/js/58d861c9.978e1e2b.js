"use strict";(globalThis.webpackChunkmydocs=globalThis.webpackChunkmydocs||[]).push([[8131],{7173:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"Quality/error-and-resilience","title":"Error and Resilience","description":"Purpose","source":"@site/docs/Quality/error-and-resilience.md","sourceDirName":"Quality","slug":"/Quality/error-and-resilience","permalink":"/brs-rmm-ai-documentation/docs/Quality/error-and-resilience","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Quality/error-and-resilience.md","tags":[{"inline":true,"label":"error-handling","permalink":"/brs-rmm-ai-documentation/docs/tags/error-handling"},{"inline":true,"label":"resilience","permalink":"/brs-rmm-ai-documentation/docs/tags/resilience"},{"inline":true,"label":"fault-tolerance","permalink":"/brs-rmm-ai-documentation/docs/tags/fault-tolerance"},{"inline":true,"label":"recovery","permalink":"/brs-rmm-ai-documentation/docs/tags/recovery"},{"inline":true,"label":"monitoring","permalink":"/brs-rmm-ai-documentation/docs/tags/monitoring"}],"version":"current","lastUpdatedBy":"Hair","lastUpdatedAt":1761836475000,"frontMatter":{"status":"draft","lastReviewed":"2025-10-08T00:00:00.000Z","owner":"members-module-team","category":"quality","tags":["error-handling","resilience","fault-tolerance","recovery","monitoring"]},"sidebar":"qualitySidebar","next":{"title":"Performance and Observability","permalink":"/brs-rmm-ai-documentation/docs/Quality/performance-and-observability"}}');var a=r(4848),t=r(8453);const l={status:"draft",lastReviewed:new Date("2025-10-08T00:00:00.000Z"),owner:"members-module-team",category:"quality",tags:["error-handling","resilience","fault-tolerance","recovery","monitoring"]},s="Error and Resilience",o={},c=[{value:"Purpose",id:"purpose",level:2},{value:"When You Need This",id:"when-you-need-this",level:2},{value:"Context / Diagram",id:"context--diagram",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Flow / Sequence",id:"flow--sequence",level:2},{value:"Rules &amp; Constraints",id:"rules--constraints",level:2},{value:"Minimal Example",id:"minimal-example",level:2},{value:"Common Pitfalls",id:"common-pitfalls",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"error-and-resilience",children:"Error and Resilience"})}),"\n",(0,a.jsx)(n.h2,{id:"purpose",children:"Purpose"}),"\n",(0,a.jsx)(n.p,{children:"Define how the module detects, classifies, and handles failures while preserving a fast, consistent user experience under partial outages or latency spikes."}),"\n",(0,a.jsx)(n.h2,{id:"when-you-need-this",children:"When You Need This"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Adding new repository methods with external calls"}),"\n",(0,a.jsx)(n.li,{children:"Designing retry / fallback logic"}),"\n",(0,a.jsx)(n.li,{children:"Standardizing error responses for frontend consumption"}),"\n",(0,a.jsx)(n.li,{children:"Performing incident post-mortems"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"context--diagram",children:"Context / Diagram"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Handler \u2192 Repository \u2192 Cache \u2192 BRS API\n                     \u2191        \u2193 (timeout / 5xx)\n              Fallback (stale) \u2190 Circuit Evaluation\n"})}),"\n",(0,a.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Error Taxonomy: Distinguish client (4xx), server (5xx), timeout, validation, and resilience policy errors"}),"\n",(0,a.jsx)(n.li,{children:"Circuit Breaker (Conceptual): Middleware can short\u2011circuit repeated failing endpoints (future enhancement)"}),"\n",(0,a.jsx)(n.li,{children:"Graceful Degradation: Use last-known good cached data when fresh fetch fails (if TTL not hard-expired)"}),"\n",(0,a.jsx)(n.li,{children:"Idempotent Retries: Safe repetition of read operations on transient failures"}),"\n",(0,a.jsx)(n.li,{children:"Standard Response Shape: Consistent JSON error envelope consumed by frontend"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"flow--sequence",children:"Flow / Sequence"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Repository executes HTTP call wrapped with timeout"}),"\n",(0,a.jsx)(n.li,{children:"Transport or 5xx error triggers exception mapping to domain exception"}),"\n",(0,a.jsx)(n.li,{children:"Handler decides fallback path: attempt stale cache if available"}),"\n",(0,a.jsx)(n.li,{children:"If fallback served, mark response metadata for observability"}),"\n",(0,a.jsx)(n.li,{children:"Controller renders problem document or successful degraded data"}),"\n",(0,a.jsx)(n.li,{children:"Frontend may emit an event to notify user of partial data freshness"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"rules--constraints",children:"Rules & Constraints"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Timeouts MUST be explicit per request (no infinite waits)"}),"\n",(0,a.jsx)(n.li,{children:"Handlers SHOULD prefer stale-but-recent cache over outright failure for read paths"}),"\n",(0,a.jsx)(n.li,{children:"Write operations MUST NOT use stale cache fallback"}),"\n",(0,a.jsxs)(n.li,{children:["Domain exceptions MUST include a stable machine code (e.g., ",(0,a.jsx)(n.code,{children:"member.not_found"}),")"]}),"\n",(0,a.jsx)(n.li,{children:"Error responses MUST avoid leaking underlying transport stack details"}),"\n",(0,a.jsx)(n.li,{children:"Retrying SHOULD be capped (e.g., single immediate retry) to avoid thundering herd"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"minimal-example",children:"Minimal Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-php",children:"try {\n  return $repo->fetchProfile($clubId, $memberId);\n} catch (MemberUpstreamTimeout $e) {\n  if ($stale = $repo->fetchProfileStale($clubId, $memberId)) {\n    return $stale; // degraded\n  }\n    throw new MemberUnavailableProblem('Timeout contacting upstream');\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Treating all exceptions the same (losing actionable classification)"}),"\n",(0,a.jsx)(n.li,{children:"Over-retrying synchronous calls increasing latency"}),"\n",(0,a.jsx)(n.li,{children:"Serving arbitrarily old cached content as fallback"}),"\n",(0,a.jsx)(n.li,{children:"Logging sensitive payload fragments"}),"\n",(0,a.jsx)(n.li,{children:"Swallowing exceptions and returning null (ambiguous failure)"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"/brs-rmm-ai-documentation/docs/Patterns/repository-and-caching-strategy",children:"Repository & Caching Strategy"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"/brs-rmm-ai-documentation/docs/Quality/testing-strategy",children:"Testing Strategy"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"/brs-rmm-ai-documentation/docs/Quality/performance-and-observability",children:"Performance and Observability"})}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>s});var i=r(6540);const a={},t=i.createContext(a);function l(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);